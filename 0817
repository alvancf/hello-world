https://github.com/react-native-oh-library/react-native-clippath/blob/sig/example/ShunFengExample.tsx
https://github.com/react-native-openharmony/rnoh/pull/789

"overrides": {
    "@rnoh/react-native-openharmony": "file:./libs/react_native_openharmony-5.0.0.490.har"
  }

https://gitee.com/react-native-oh-library/usage-docs/blob/master/zh-cn/react-native-clippath-capi.md
import React, {useEffect, useState} from 'react';
import {Text} from 'react-native';

function App(): JSX.Element {
  useEffect(() => {
    // 组件挂载后执行的代码
    console.log('Component mounted!');
    let formData = new FormData();
    let file = {
      uri: '/data/storage/el2/base/haps/entry/cache/ReactNative_cropped_image_1718181899621.jpg',
      type: 'image/jpeg', //type: 'multipart/form-data',
      name: 'IMG',
    };
    formData.append('files', file);
    // formData = {
    //   cc: 222,
    // };
    // formData.append('files', JSON.stringify(file));
    fetch('https://www.baidu.com', {
      method: 'post',
      headers: {
        'content-Type': 'multipart/form-data',
      },
      // headers: {
      //   'content-Type': 'application/json',
      // },
      body: formData,
    }).then(req => {
      console.log('req:', req);
      setSelectedIndex(2);
      req.json();
    });

    // 返回一个清理函数，组件卸载时执行
    return () => {
      console.log('Component unmounted!');
      // 在这里清除定时器、取消网络请求或移除订阅等
    };
  }, []); // 空数组表示这个effect只在组件挂载和卸载时运行
  const [selectedIndex, setSelectedIndex] = useState(1);
  return (
    <Text
      style={{
        flex: 1,
        marginTop: 80,
        alignItems: 'center',
        justifyContent: 'center',
      }}>
      {selectedIndex}
    </Text>
  );
}
export default App;



https://gitee.com/react-native-oh-library/usage-docs/blob/master/zh-cn/react-native-clippathview.md#%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8

import { View, Text, Image, ScrollView, Animated, Dimensions, PixelRatio, Button, StyleSheet, Easing } from 'react-native'
import React, { useRef, useState, useEffect, forwardRef, useMemo, useCallback } from 'react'
import { ClipPathView } from 'react-native-clippathview'
import { banner01 } from './imageData'

const windowDimensions = Dimensions.get('window');
const screenDimensions = Dimensions.get('screen');

const windowWidth = windowDimensions.width;
const windowHeight = windowDimensions.height;

const widthPx = PixelRatio.getPixelSizeForLayoutSize(windowWidth);
const heightPx = PixelRatio.getPixelSizeForLayoutSize(windowHeight);

const CustomView = React.forwardRef((props, ref) => {
// some additional logic
console.log(props.style)
return (
<ClipPathView ref={ref} {...props} fill="#f00">
{/* <Text style={{ color: '#ff0' }}>custom view</Text>
<Text style={{ color: '#ff0' }}>{props.d}</Text> */}
{props.children}
</ClipPathView>
)
});

// const AnimatedClipPath = Animated.createAnimatedComponent(CustomView);
const AnimatedClipPath = Animated.createAnimatedComponent(ClipPathView);

export default function index() {
const [moveY, setMoveY] = useState(0);
const offset = useRef(new Animated.Value(0)).current;
const headerViewHeight = 200;
const pathHeight = PixelRatio.getPixelSizeForLayoutSize(headerViewHeight);
const screenWidth = widthPx - PixelRatio.getPixelSizeForLayoutSize(32);
const ScreenConstant = {
height: 900,
};

const generatePath = (arcDepth: number) => {
return `M 0 0 L 0 ${pathHeight + arcDepth} Q ${screenWidth / 2} ${pathHeight - arcDepth - 1} ${screenWidth} ${pathHeight + arcDepth} L ${screenWidth} 0 L 0 0 Z`;
};

const finalD = useMemo(() => {
const d = offset?.interpolate({
inputRange: [-headerViewHeight, -26, 0],
outputRange: [generatePath(-26), generatePath(-26), generatePath(0)],
});
return d.__getValue();
}, [moveY])

const transY = useMemo(() => {
let y = offset.interpolate({
inputRange: [
-ScreenConstant.height,
-headerViewHeight,
0,
ScreenConstant.height,
],
outputRange: [
headerViewHeight - ScreenConstant.height,
0,
0,
0,
],
});
return y.__getValue();
}, [moveY])

const scrollHandle = (ev) => {
// console.log('FG scroll ', JSON.stringify(ev))
const contentHeight = ev.nativeEvent.contentSize.height;
const offsetY = Math.ceil(ev.nativeEvent.contentOffset.y);
console.log("FG scroll", contentHeight, offsetY)

if (offsetY <= 0) {
// setMoveY(offsetY);
// console.log(typeof offsetY)
offset.setValue(offsetY);
}
};

const onScrollBeginDrag = (ev) => { };

const onScrollEndDrag = (ev) => { };

return (
<ScrollView style={{ width: '100%', height: '100%', backgroundColor: 'rgba(0, 255, 0, 0.1)' }}
onScroll={scrollHandle}
onScrollBeginDrag={onScrollBeginDrag}
onScrollEndDrag={onScrollEndDrag}
>
<AnimatedClipPath
style={{
zIndex: 1,
backgroundColor: '#201E1E',
// width: 375,
// height: 1000,
width: windowWidth - 32,
height: headerViewHeight,
// position: 'absolute',
flexDirection: 'column-reverse',
transform: [
{
translateY:
offset.interpolate({
inputRange: [
// -100000,
-ScreenConstant.height,
-headerViewHeight,
0,
// 100000
ScreenConstant.height,
],
outputRange: [
headerViewHeight - ScreenConstant.height,
0,
0,
0,
],
}) ?? 0,
},
],
}}
d={offset?.interpolate({
inputRange: [-headerViewHeight, -26, 0],
outputRange: [generatePath(-26), generatePath(-26), generatePath(0)],
})}
>
<Image
style={{ width: '100%', height: '100%' }}
source={{
uri: banner01,
}}
/>
</AnimatedClipPath>

<Text></Text>
<View style={{ padding: 20, backgroundColor: "rgba(0,0,255, 0.2)" }}>
<Text>windowDimensions: {JSON.stringify(windowDimensions)}</Text>
<Text>screenDimensions: {JSON.stringify(screenDimensions)}</Text>
<Text>widthPx: {widthPx}</Text>
<Text>heightPx: {heightPx}</Text>
<Text>32: {PixelRatio.getPixelSizeForLayoutSize(32)}</Text>
<Text>headerViewHeight: {headerViewHeight}</Text>
<Text>ScreenConstant height: {ScreenConstant.height}</Text>
<Text>transY：{transY}</Text>
<Text>moveY: {moveY}</Text>
<Text></Text>
<Text></Text>
<Text>{finalD}</Text>
{/* <Text>{finalPath}</Text> */}

</View>

</ScrollView>
)
}

// <AnimatedClipPathView
// style={{
// zIndex: 1,
// backgroundColor: "#201E1E",
// width: 375,
// height: 60,
// position: "absolute",
// flexDirection: "column-reverse",
// transform: [
// {
// translateY:
// this.props.offset?.interpolate({
// inputRange: [
// -ScreenConstant.height,
// -headerViewHeight,
// 0,
// ScreenConstant.height
// ],
// outputRange: [
// headerViewHeight - ScreenConstant.height,
// 0,
// 0,
// 0
// ]
// }) ?? 0
// }
// ]
// }}
// d={offset?.interpolate({
// inputRange: [-headerViewHeight, -26, 0],
// outputRange: [generatePath(-26), generatePath(-26), generatePath(0)]
// })}
// >

const styles = StyleSheet.create({
cpvContainer: {
width: '100%',
height: '100%',
},
container: {
flex: 1,
// alignItems: 'center',
// justifyContent: 'center',
},
transformOriginWrapper: {
borderWidth: 1,
borderColor: 'rgba(0, 0, 0, 0.5)',
},
transformOriginView: {
backgroundColor: 'pink',
width: 100,
height: 100,
// transformOrigin: 'center',
transformOrigin: 'left top',
},
});
git submodule update --init --recursive

testerino：npm pack，
react-native-harmony-cli：npm i + npm pack，

react-native-harmony：npm i + npm pack， 

react-native-harmony-sample-package：npm i + npm pack，

最后tester：npm run i + npm run dev
携程旅行
小红书
快手
喜马拉雅
爱奇艺
滴滴出行
中国工商银行
知乎
YY
叮咚买菜
网上国网
和家亲
瑞幸咖啡
顺丰速运
安居客
平安好车主
驾校一点通
途虎养车
汽车之家
瓜子二手车
智行火车票
云闪付
平安口袋银行
东方财富
浦发银行
平安金管家
萤石云视频
网易云音乐
今日水印相机
深信服零信任
https://gl.swmansion.com/rnoh/react-native-harmony/-/merge_requests/1500/diffs



_handleContentOnLayout = (e: LayoutEvent) => {
    const { width, height } = e.nativeEvent.layout;
      /**
       * RNOH patch - Fixed the issue where sticky headers are in disordered position after foldable phone is expanded/folded.
       * When a foldable phone is expanded/folded, the height of the list items often changes,
       * causing the content height of the ScrollView to change.
       * But since the scroll event is not triggered, the position of the sticky headers is 
       * still offset according to the original content height.
       * So we should recalculate the contentOffset based on the new contentHeight and trigger 
       * the scroll event to fix the position of sticky headers
       */
      let { contentOffset, contentHeight, layoutHeight } = this.state;
      if (contentOffset && contentHeight) {
        console.log('contentOffset:', contentOffset)
        console.log('layoutHeight:', layoutHeight)
        console.log('contentHeight:', contentHeight)
        console.log('layoutHeight:', layoutHeight)
        console.log('height:', height)
        contentOffset *= (height - layoutHeight) / (contentHeight - layoutHeight);
  
        (contentOffset < 0) && (contentOffset = 0);
        // 2042 1986
        console.log('contentOffset:', contentOffset)
        this.scrollTo({ y: contentOffset, animated: false });
        this._scrollAnimatedValue.setValue(contentOffset);
      }
      this.setState({
        contentOffset,
        contentHeight: height
      });
      /**
       * 本意是在折叠屏屏幕变化时，触发layout事件，根据当前滚动条的位置去重新计算滚动条应该加载的位置
       * 但是在虚拟列表中，触发scrollTo的过程中，也会触发layout事件，使用Animate时scrollTo还没完全完成，导致拿到的滚动条位置是错的！
       * 等scrollTo加载完成再去拿位置，动画加载的默认时间大概是250ms，设置这个时间为250ms
      */
      this.props.onContentSizeChange &&
        this.props.onContentSizeChange(width, height);
  };
const debounce = (func, delay) => {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
};

const scrollToSpecificItem = debounce(() => {
  flatListRef.current.scrollToItem({
    item: DATA[49],
    animated: true,
    viewPosition: 0.5,
  });
}, 300); // 防抖处理，300ms 内只触发一次


import React from 'react';
import { SafeAreaView, View, VirtualizedList, StyleSheet, Text } from 'react-native';
import Constants from 'expo-constants';
    testContainer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        backgroundColor: '#f2f2f7ff',
        height: 40,
      },
 item: {
      backgroundColor: '#f9c2ff',
      height: 40,
      justifyContent: 'center',
      marginVertical: 8,
      marginHorizontal: 16,
    },
    title: {
      fontSize: 32,
    },
const GENERATED_DATA = Array.from({length: 100}, (_, index) => ({
  id: Math.random().toString(12).substring(0),
  title: `Item ${index + 1}`,
}));
    const Item = ({title}) => (
      <View style={styles.item}>
        <Text style={styles.title}>{title}</Text>
      </View>
    );
      <View style={styles.viewStyle}>
        <View testID="test_container" style={styles.testContainer}>
            <Text style={{paddingTop:10,paddingLeft:10}}>实际效果:</Text>
            <Button
            title='Toggle1'
            onPress={() => {ref.current.scrollToItem({item: GENERATED_DATA[2], animated: true});} }
            ></Button>
          <Button
            title='Toggle2'
            onPress={() => {
              ref.current?.scrollToItem({
                animated: true,
                item: CCDATA[2],
              });
            }}
          ></Button>
        </View>
                 <VirtualizedList
              ref = {vRef}
              initialNumToRender={10}
              data={GENERATED_DATA}
              renderItem={(item) => <Item title={item.title} />}
              keyExtractor={item => item.id}
              getItemCount={() => GENERATED_DATA.length}
              getItem={(data, index) => GENERATED_DATA[index]}
              />
        {/* <VirtualizedList
          data={DATA}
          initialNumToRender={4}
          renderItem={({ item }) => <Item title={item.title} />}
          keyExtractor={item => item.key}
          getItemCount={getItemCount}
          getItem={getItem}
        /> */}
        {/* <FlatList
          ref={ref}
          renderItem={({ item }) => <Item title={item.title} />}
          keyExtractor={item => item.id}
          data={DATA}
        /> */}
      </View>

 viewStyle:{
      width:300,
      height:240,
      marginBottom:30,
      borderWidth:1,
      borderColor:'black',
      borderStyle:'solid',
      marginLeft:40,
    },


const DATA = [];
const getItem = (data, index) => {
  return {
    id: Math.random().toString(12).substring(0),
    title: `Item ${index+1}`
  }
}
const getItemCount = (data) => {
  return 50;
}
const Item = ({ title })=> {
  return (
    <View style={styles.item}>
      <Text style={styles.title}>{title}</Text>
    </View>
  );
}
const VirtualizedListExample = () => {
  return (
    <SafeAreaView style={styles.container}>
      <VirtualizedList
        data={DATA}
        initialNumToRender={4}
        renderItem={({ item }) => <Item title={item.title} />}
        keyExtractor={item => item.key}
        getItemCount={getItemCount}
        getItem={getItem}
      />
    </SafeAreaView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop: Constants.statusBarHeight,
  },
  item: {
    backgroundColor: '#f9c2ff',
    height: 150,
    justifyContent: 'center',
    marginVertical: 8,
    marginHorizontal: 16,
    padding: 20,
  },
  title: {
    fontSize: 32,
  },
});
export default VirtualizedListExample;
